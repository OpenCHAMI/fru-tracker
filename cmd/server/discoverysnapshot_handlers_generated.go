// Code generated by Fabrica dev. DO NOT EDIT.
// Template: server/handlers.go.tmpl
// Generated: 2026-02-26T11:12:39-08:00
//
// # Copyright Â© 2025 OpenCHAMI a Series of LF Projects, LLC
//
// SPDX-License-Identifier: MIT
//
// This file contains REST API handlers for DiscoverySnapshot resources.
//
// To modify this code:
//  1. Edit the template file: pkg/codegen/templates/handlers.go.tmpl
//  2. Run 'make dev' to regenerate
//  3. Do NOT edit this file directly - changes will be lost
//
// Generated handlers provide:
//   - GET /discoverysnapshots (list all discoverysnapshots)
//   - GET /discoverysnapshots/{uid} (get specific DiscoverySnapshot)
//   - POST /discoverysnapshots (create new DiscoverySnapshot)
//   - PUT /discoverysnapshots/{uid} (update DiscoverySnapshot spec)
//   - PATCH /discoverysnapshots/{uid} (patch DiscoverySnapshot spec)
//   - DELETE /discoverysnapshots/{uid} (delete DiscoverySnapshot)
//   - PUT /discoverysnapshots/{uid}/status (update DiscoverySnapshot status)
//   - PATCH /discoverysnapshots/{uid}/status (patch DiscoverySnapshot status)
//
// Authorization: Add custom middleware for authentication/authorization
// Storage: Uses storage.LoadDiscoverySnapshot*/SaveDiscoverySnapshot*/DeleteDiscoverySnapshot*
// Version Support: Available (see version context in handlers)
//
// To enable full version conversion for this resource:
//  1. Add new version: fabrica add version <group> <version>
//  2. Implement converter: apis/<group>/<version>/converter.go
//  3. Add version-aware storage: storage.LoadDiscoverySnapshotWithVersion()
//  4. Register versions in cmd/server/main.go
package main

import (
	"encoding/json"
	"fmt"
	"io"
	"net/http"
	"time"

	v1 "github.com/example/fru-tracker/apis/example.fabrica.dev/v1"
	"github.com/go-chi/chi/v5"
	"github.com/openchami/fabrica/pkg/events"
	"github.com/openchami/fabrica/pkg/patch"
	"github.com/openchami/fabrica/pkg/resource"
	"github.com/openchami/fabrica/pkg/validation"
	"github.com/openchami/fabrica/pkg/versioning"

	"github.com/example/fru-tracker/internal/storage"
)

// GetDiscoverySnapshots returns all DiscoverySnapshot resources
func GetDiscoverySnapshots(w http.ResponseWriter, r *http.Request) {
	// Authorization: Add custom middleware in routes.go or implement checks here
	// Example: if !authorized(r) { respondError(w, http.StatusUnauthorized, fmt.Errorf("unauthorized")); return }

	discoverysnapshots, err := storage.LoadAllDiscoverySnapshots(r.Context())
	if err != nil {
		respondError(w, http.StatusInternalServerError, fmt.Errorf("failed to load discoverysnapshots: %w", err))
		return
	}
	respondJSON(w, http.StatusOK, discoverysnapshots)
}

// GetDiscoverySnapshot returns a specific DiscoverySnapshot resource by UID
func GetDiscoverySnapshot(w http.ResponseWriter, r *http.Request) {
	uid := chi.URLParam(r, "uid")
	if uid == "" {
		respondError(w, http.StatusBadRequest, fmt.Errorf("DiscoverySnapshot UID is required"))
		return
	}

	// Version context available here for version-aware operations
	// versionCtx := versioning.GetVersionContext(r.Context())
	// Requested version: versionCtx.ServeVersion
	// To enable: replace storage.LoadDiscoverySnapshot() with version-aware function

	// Authorization: Add custom middleware in routes.go or implement checks here
	// Example: if !authorized(r) { respondError(w, http.StatusUnauthorized, fmt.Errorf("unauthorized")); return }

	discoverySnapshot, err := storage.LoadDiscoverySnapshot(r.Context(), uid)
	if err != nil {
		respondError(w, http.StatusNotFound, fmt.Errorf("DiscoverySnapshot not found: %w", err))
		return
	}
	respondJSON(w, http.StatusOK, discoverySnapshot)
}

// CreateDiscoverySnapshot creates a new DiscoverySnapshot resource
func CreateDiscoverySnapshot(w http.ResponseWriter, r *http.Request) {
	var req CreateDiscoverySnapshotRequest
	if err := json.NewDecoder(r.Body).Decode(&req); err != nil {
		respondError(w, http.StatusBadRequest, fmt.Errorf("invalid request body: %w", err))
		return
	}

	// Layer 1: Request validation (validates inline spec fields and metadata)
	if err := validation.ValidateResource(&req); err != nil {
		respondError(w, http.StatusBadRequest, fmt.Errorf("validation failed: %w", err))
		return
	}

	// Get version context from request (set by version negotiation middleware)
	versionCtx := versioning.GetVersionContext(r.Context())

	uid, err := resource.GenerateUIDForResource("DiscoverySnapshot")
	if err != nil {
		respondError(w, http.StatusInternalServerError, fmt.Errorf("failed to generate UID: %w", err))
		return
	}

	// Versioned mode: flat fields with fabrica.Metadata
	discoverySnapshot := &v1.DiscoverySnapshot{
		// Use negotiated ServeVersion (from Accept header) for apiVersion
		APIVersion: versionCtx.ServeVersion,
		Kind:       "DiscoverySnapshot",
		Spec:       req.AsSpec(),
	}

	// Initialize metadata from request
	discoverySnapshot.Metadata = req.Metadata
	discoverySnapshot.Metadata.UID = uid
	now := time.Now()
	discoverySnapshot.Metadata.CreatedAt = now
	discoverySnapshot.Metadata.UpdatedAt = now

	// Set labels and annotations
	if discoverySnapshot.Metadata.Labels == nil {
		discoverySnapshot.Metadata.Labels = make(map[string]string)
	}
	for k, v := range req.Labels {
		discoverySnapshot.Metadata.Labels[k] = v
	}
	if discoverySnapshot.Metadata.Annotations == nil {
		discoverySnapshot.Metadata.Annotations = make(map[string]string)
	}
	for k, v := range req.Annotations {
		discoverySnapshot.Metadata.Annotations[k] = v
	}

	// Layer 2: Custom business logic validation
	if err := validation.ValidateWithContext(r.Context(), discoverySnapshot); err != nil {
		respondError(w, http.StatusBadRequest, fmt.Errorf("validation failed: %w", err))
		return
	}

	// Set initial status
	// This assumes the generator passes an 'IsReconcilable' boolean
	// to this template, and that the resource has a .Status.Phase field.

	// Save (Layer 1: Ent validation happens automatically if using Ent storage)
	if err := storage.SaveDiscoverySnapshot(r.Context(), discoverySnapshot); err != nil {
		respondError(w, http.StatusInternalServerError, fmt.Errorf("failed to save DiscoverySnapshot: %w", err))
		return
	}

	// Publish resource created event

	if err := events.PublishResourceCreated(r.Context(), "DiscoverySnapshot", discoverySnapshot.Metadata.UID, discoverySnapshot.Metadata.Name, discoverySnapshot); err != nil {
		// Log the error but don't fail the request - events are non-critical
		fmt.Printf("Warning: Failed to publish resource created event for DiscoverySnapshot %s: %v\n", discoverySnapshot.Metadata.UID, err)

	}

	respondJSON(w, http.StatusCreated, discoverySnapshot)
}

// UpdateDiscoverySnapshot updates the spec of an existing DiscoverySnapshot resource
// NOTE: This endpoint ONLY updates the spec. Use PUT //discoverysnapshots/{uid}/status to update status.
func UpdateDiscoverySnapshot(w http.ResponseWriter, r *http.Request) {
	uid := chi.URLParam(r, "uid")
	if uid == "" {
		respondError(w, http.StatusBadRequest, fmt.Errorf("DiscoverySnapshot UID is required"))
		return
	}

	discoverySnapshot, err := storage.LoadDiscoverySnapshot(r.Context(), uid)
	if err != nil {
		respondError(w, http.StatusNotFound, fmt.Errorf("DiscoverySnapshot not found: %w", err))
		return
	}

	var req UpdateDiscoverySnapshotRequest
	if err := json.NewDecoder(r.Body).Decode(&req); err != nil {
		respondError(w, http.StatusBadRequest, fmt.Errorf("invalid request body: %w", err))
		return
	}

	// Apply updates

	// Versioned mode: direct field access
	if req.Metadata.Name != "" {
		discoverySnapshot.Metadata.Name = req.Metadata.Name
	}

	// Update spec fields ONLY - status should use /status subresource
	discoverySnapshot.Spec = req.AsSpec()

	// Update labels and annotations
	if discoverySnapshot.Metadata.Labels == nil {
		discoverySnapshot.Metadata.Labels = make(map[string]string)
	}
	for k, v := range req.Labels {
		discoverySnapshot.Metadata.Labels[k] = v
	}
	if discoverySnapshot.Metadata.Annotations == nil {
		discoverySnapshot.Metadata.Annotations = make(map[string]string)
	}
	for k, v := range req.Annotations {
		discoverySnapshot.Metadata.Annotations[k] = v
	}

	// Update timestamp
	discoverySnapshot.Metadata.UpdatedAt = time.Now()

	if err := storage.SaveDiscoverySnapshot(r.Context(), discoverySnapshot); err != nil {
		respondError(w, http.StatusInternalServerError, fmt.Errorf("failed to save DiscoverySnapshot: %w", err))
		return
	}

	// Publish resource updated event
	updateMetadata := map[string]interface{}{
		"updatedAt": discoverySnapshot.Metadata.UpdatedAt,
	}

	if err := events.PublishResourceUpdated(r.Context(), "DiscoverySnapshot", discoverySnapshot.Metadata.UID, discoverySnapshot.Metadata.Name, discoverySnapshot, updateMetadata); err != nil {
		// Log the error but don't fail the request - events are non-critical
		fmt.Printf("Warning: Failed to publish resource updated event for DiscoverySnapshot %s: %v\n", discoverySnapshot.Metadata.UID, err)

	}

	respondJSON(w, http.StatusOK, discoverySnapshot)
}

// PatchDiscoverySnapshot patches an existing DiscoverySnapshot resource spec using JSON Merge Patch, JSON Patch, or Shorthand Patch
// Only the spec portion of the resource can be patched - metadata and status are API-managed
func PatchDiscoverySnapshot(w http.ResponseWriter, r *http.Request) {
	uid := chi.URLParam(r, "uid")
	if uid == "" {
		respondError(w, http.StatusBadRequest, fmt.Errorf("DiscoverySnapshot UID is required"))
		return
	}

	discoverySnapshot, err := storage.LoadDiscoverySnapshot(r.Context(), uid)
	if err != nil {
		respondError(w, http.StatusNotFound, fmt.Errorf("DiscoverySnapshot not found: %w", err))
		return
	}

	// Read patch document
	patchData, err := io.ReadAll(r.Body)
	if err != nil {
		respondError(w, http.StatusBadRequest, fmt.Errorf("failed to read patch data: %w", err))
		return
	}

	// Marshal current spec to JSON for patching (only allow spec modifications)
	currentSpecJSON, err := json.Marshal(discoverySnapshot.Spec)
	if err != nil {
		respondError(w, http.StatusInternalServerError, fmt.Errorf("failed to marshal current spec: %w", err))
		return
	}

	// Detect patch type from Content-Type header
	contentType := r.Header.Get("Content-Type")
	patchType := patch.DetectPatchType(contentType)

	// Apply patch to spec only
	patchResult, err := patch.ApplyPatchWithOptions(currentSpecJSON, patchData, patchType, patch.PatchOptions{
		AllowAddFields:    true,
		AllowRemoveFields: true,
	})
	if err != nil {
		respondError(w, http.StatusUnprocessableEntity, fmt.Errorf("failed to apply patch to spec: %w", err))
		return
	}

	// Unmarshal the patched result back to the spec
	if err := json.Unmarshal(patchResult.Updated, &discoverySnapshot.Spec); err != nil {
		respondError(w, http.StatusInternalServerError, fmt.Errorf("failed to unmarshal patched spec: %w", err))
		return
	}

	// Touch to update metadata

	discoverySnapshot.Metadata.UpdatedAt = time.Now()

	// Save the patched resource
	if err := storage.SaveDiscoverySnapshot(r.Context(), discoverySnapshot); err != nil {
		respondError(w, http.StatusInternalServerError, fmt.Errorf("failed to save patched DiscoverySnapshot: %w", err))
		return
	}

	// Publish resource patched event
	patchMetadata := map[string]interface{}{
		"patchType": patchType,
		"updatedAt": discoverySnapshot.Metadata.UpdatedAt,
	}

	if err := events.PublishResourcePatched(r.Context(), "DiscoverySnapshot", discoverySnapshot.Metadata.UID, discoverySnapshot.Metadata.Name, discoverySnapshot, patchMetadata); err != nil {
		// Log the error but don't fail the request - events are non-critical
		fmt.Printf("Warning: Failed to publish resource patched event for DiscoverySnapshot %s: %v\n", discoverySnapshot.Metadata.UID, err)

	}

	respondJSON(w, http.StatusOK, discoverySnapshot)
}

// UpdateDiscoverySnapshotStatus updates only the status of a DiscoverySnapshot resource
// This endpoint is intended for controllers, reconcilers, and monitoring systems.
// It does not modify the spec or metadata (except updatedAt timestamp).
//
// Authorization: Requires 'update_status' permission (separate from 'update' permission)
// Events: Publishes resource updated event with updateType: "status"
func UpdateDiscoverySnapshotStatus(w http.ResponseWriter, r *http.Request) {
	uid := chi.URLParam(r, "uid")
	if uid == "" {
		respondError(w, http.StatusBadRequest, fmt.Errorf("DiscoverySnapshot UID is required"))
		return
	}

	// Authorization: Add custom middleware for status update authorization
	// Status updates can have different permissions than spec updates

	res, err := storage.LoadDiscoverySnapshot(r.Context(), uid)
	if err != nil {
		respondError(w, http.StatusNotFound, fmt.Errorf("DiscoverySnapshot not found: %w", err))
		return
	}

	var statusUpdate v1.DiscoverySnapshotStatus
	if err := json.NewDecoder(r.Body).Decode(&statusUpdate); err != nil {
		respondError(w, http.StatusBadRequest, fmt.Errorf("invalid status body: %w", err))
		return
	}

	// Preserve spec - only update status
	res.Status = statusUpdate

	res.Metadata.UpdatedAt = time.Now()

	if err := storage.SaveDiscoverySnapshot(r.Context(), res); err != nil {
		respondError(w, http.StatusInternalServerError, fmt.Errorf("failed to save DiscoverySnapshot status: %w", err))
		return
	}

	// Publish status update event
	statusMetadata := map[string]interface{}{
		"updatedAt":  res.Metadata.UpdatedAt,
		"updateType": "status",
	}

	if err := events.PublishResourceUpdated(r.Context(), "DiscoverySnapshot", res.Metadata.UID, res.Metadata.Name, res, statusMetadata); err != nil {
		// Log but don't fail - events are non-critical
		fmt.Printf("Warning: Failed to publish status update event for DiscoverySnapshot %s: %v\n", res.Metadata.UID, err)

	}

	respondJSON(w, http.StatusOK, res)
}

// PatchDiscoverySnapshotStatus patches only the status of a DiscoverySnapshot resource
// Supports JSON Merge Patch, JSON Patch, and Shorthand Patch formats.
// Only modifies status fields - spec and metadata are preserved.
func PatchDiscoverySnapshotStatus(w http.ResponseWriter, r *http.Request) {
	uid := chi.URLParam(r, "uid")
	if uid == "" {
		respondError(w, http.StatusBadRequest, fmt.Errorf("DiscoverySnapshot UID is required"))
		return
	}

	// Authorization: Add custom middleware for status patch authorization
	// Status patches can have different permissions than spec patches

	res, err := storage.LoadDiscoverySnapshot(r.Context(), uid)
	if err != nil {
		respondError(w, http.StatusNotFound, fmt.Errorf("DiscoverySnapshot not found: %w", err))
		return
	}

	patchData, err := io.ReadAll(r.Body)
	if err != nil {
		respondError(w, http.StatusBadRequest, fmt.Errorf("failed to read patch data: %w", err))
		return
	}

	// Marshal current status for patching
	currentStatusJSON, err := json.Marshal(res.Status)
	if err != nil {
		respondError(w, http.StatusInternalServerError, fmt.Errorf("failed to marshal current status: %w", err))
		return
	}

	contentType := r.Header.Get("Content-Type")
	patchType := patch.DetectPatchType(contentType)

	patchResult, err := patch.ApplyPatchWithOptions(currentStatusJSON, patchData, patchType, patch.PatchOptions{
		AllowAddFields:    true,
		AllowRemoveFields: false, // Don't allow removing status fields
	})
	if err != nil {
		respondError(w, http.StatusUnprocessableEntity, fmt.Errorf("failed to apply patch to status: %w", err))
		return
	}

	// Unmarshal patched status back
	if err := json.Unmarshal(patchResult.Updated, &res.Status); err != nil {
		respondError(w, http.StatusInternalServerError, fmt.Errorf("failed to unmarshal patched status: %w", err))
		return
	}

	res.Metadata.UpdatedAt = time.Now()

	if err := storage.SaveDiscoverySnapshot(r.Context(), res); err != nil {
		respondError(w, http.StatusInternalServerError, fmt.Errorf("failed to save patched DiscoverySnapshot status: %w", err))
		return
	}

	// Publish status patch event
	patchMetadata := map[string]interface{}{
		"patchType":  patchType,
		"updatedAt":  res.Metadata.UpdatedAt,
		"updateType": "status",
	}

	if err := events.PublishResourcePatched(r.Context(), "DiscoverySnapshot", res.Metadata.UID, res.Metadata.Name, res, patchMetadata); err != nil {
		fmt.Printf("Warning: Failed to publish status patch event for DiscoverySnapshot %s: %v\n", res.Metadata.UID, err)

	}

	respondJSON(w, http.StatusOK, res)
}

// DeleteDiscoverySnapshot deletes a DiscoverySnapshot resource
func DeleteDiscoverySnapshot(w http.ResponseWriter, r *http.Request) {
	uid := chi.URLParam(r, "uid")
	if uid == "" {
		respondError(w, http.StatusBadRequest, fmt.Errorf("DiscoverySnapshot UID is required"))
		return
	}

	// Load resource before deletion for event publishing
	discoverySnapshot, err := storage.LoadDiscoverySnapshot(r.Context(), uid)
	if err != nil {
		respondError(w, http.StatusNotFound, fmt.Errorf("DiscoverySnapshot not found: %w", err))
		return
	}

	if err := storage.DeleteDiscoverySnapshot(r.Context(), uid); err != nil {
		respondError(w, http.StatusInternalServerError, fmt.Errorf("failed to delete DiscoverySnapshot: %w", err))
		return
	}

	// Publish resource deleted event
	deleteMetadata := map[string]interface{}{
		"deletedAt": time.Now(),
	}

	if err := events.PublishResourceDeleted(r.Context(), "DiscoverySnapshot", discoverySnapshot.Metadata.UID, discoverySnapshot.Metadata.Name, deleteMetadata); err != nil {
		// Log the error but don't fail the request - events are non-critical
		fmt.Printf("Warning: Failed to publish resource deleted event for DiscoverySnapshot %s: %v\n", discoverySnapshot.Metadata.UID, err)

	}

	respondJSON(w, http.StatusOK, &DeleteResponse{
		Message: "DiscoverySnapshot deleted successfully",
		UID:     uid,
	})
}
