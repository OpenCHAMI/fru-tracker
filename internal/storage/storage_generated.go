// Code generated by Fabrica. DO NOT EDIT.
// Copyright Â© 2025 OpenCHAMI a Series of LF Projects, LLC
//
// SPDX-License-Identifier: MIT
//
// This file provides storage functions using Ent as the backend.
// The functions maintain the same interface as file storage for compatibility.

package storage

import (
	"context"
	"encoding/json"
	"errors"
	"fmt"
	"time"

	"github.com/openchami/fabrica/pkg/reconcile"
	fabricaStorage "github.com/openchami/fabrica/pkg/storage"

	"github.com/example/fru-tracker/internal/storage/ent"
	entresource "github.com/example/fru-tracker/internal/storage/ent/resource"

	v1 "github.com/example/fru-tracker/apis/example.fabrica.dev/v1"
)

// ErrNotFound indicates that a resource was not found
var ErrNotFound = errors.New("resource not found")

// Ent client (initialized in main.go)
var entClient *ent.Client

// SetEntClient sets the Ent client for storage operations
func SetEntClient(client *ent.Client) {
	entClient = client
}

// LoadAllDevices loads all Device resources from Ent storage
func LoadAllDevices(ctx context.Context) ([]*v1.Device, error) {
	if entClient == nil {
		return nil, fmt.Errorf("ent client not initialized")
	}

	// Query all resources of this kind
	entResources, err := entClient.Resource.Query().
		Where(entresource.KindEQ("Device")).
		WithLabels().
		WithAnnotations().
		All(ctx)
	if err != nil {
		return nil, fmt.Errorf("failed to load Device resources: %w", err)
	}

	// Convert to Fabrica resources
	var resources []*v1.Device
	for _, entResource := range entResources {
		fabricaResource, err := FromEntResource(ctx, entResource)
		if err != nil {
			// Log error but continue with other resources
			continue
		}
		resources = append(resources, fabricaResource.(*v1.Device))
	}

	return resources, nil
}

// LoadDevice loads a single Device resource by UID from Ent storage
func LoadDevice(ctx context.Context, uid string) (*v1.Device, error) {
	if entClient == nil {
		return nil, fmt.Errorf("ent client not initialized")
	}

	// Query by UID and kind
	entResource, err := entClient.Resource.Query().
		Where(
			entresource.UIDEQ(uid),
			entresource.KindEQ("Device"),
		).
		WithLabels().
		WithAnnotations().
		Only(ctx)
	if err != nil {
		if ent.IsNotFound(err) {
			return nil, ErrNotFound
		}
		return nil, fmt.Errorf("failed to load Device %s: %w", uid, err)
	}

	// Convert to Fabrica resource
	fabricaResource, err := FromEntResource(ctx, entResource)
	if err != nil {
		return nil, err
	}

	return fabricaResource.(*v1.Device), nil
}

// SaveDevice saves a Device resource to Ent storage
func SaveDevice(ctx context.Context, resource *v1.Device) error {
	if entClient == nil {
		return fmt.Errorf("ent client not initialized")
	}

	// Convert to Ent entity
	createBuilder, labels, annotations, err := ToEntResource(resource)
	if err != nil {
		return fmt.Errorf("failed to convert Device to ent: %w", err)
	}

	// Use upsert pattern: try to update, if not exists then create
	entResource, err := entClient.Resource.Query().
		Where(entresource.UIDEQ(resource.GetUID())).
		Only(ctx)

	if err != nil && !ent.IsNotFound(err) {
		return fmt.Errorf("failed to check Device existence: %w", err)
	}

	var savedResource *ent.Resource
	if ent.IsNotFound(err) {
		// Create new resource
		savedResource, err = createBuilder.Save(ctx)
		if err != nil {
			return fmt.Errorf("failed to create Device: %w", err)
		}
	} else {
		// Update existing resource
		spec, _ := json.Marshal(resource.Spec)
		status, _ := json.Marshal(resource.Status)

		savedResource, err = entClient.Resource.UpdateOne(entResource).
			SetName(resource.Metadata.Name).
			SetAPIVersion(resource.APIVersion).
			SetSpec(spec).
			SetStatus(status).
			SetUpdatedAt(time.Now()).
			Save(ctx)
		if err != nil {
			return fmt.Errorf("failed to update Device: %w", err)
		}
	}

	// Save labels
	if err := saveLabels(ctx, savedResource.ID, labels); err != nil {
		return err
	}

	// Save annotations
	if err := saveAnnotations(ctx, savedResource.ID, annotations); err != nil {
		return err
	}

	return nil
}

// DeleteDevice deletes a Device resource from Ent storage
func DeleteDevice(ctx context.Context, uid string) error {
	if entClient == nil {
		return fmt.Errorf("ent client not initialized")
	}

	// Delete by UID
	deleted, err := entClient.Resource.Delete().
		Where(
			entresource.UIDEQ(uid),
			entresource.KindEQ("Device"),
		).
		Exec(ctx)

	if err != nil {
		return fmt.Errorf("failed to delete Device %s: %w", uid, err)
	}

	if deleted == 0 {
		return ErrNotFound
	}

	return nil
}

// LoadAllDiscoverySnapshots loads all DiscoverySnapshot resources from Ent storage
func LoadAllDiscoverySnapshots(ctx context.Context) ([]*v1.DiscoverySnapshot, error) {
	if entClient == nil {
		return nil, fmt.Errorf("ent client not initialized")
	}

	// Query all resources of this kind
	entResources, err := entClient.Resource.Query().
		Where(entresource.KindEQ("DiscoverySnapshot")).
		WithLabels().
		WithAnnotations().
		All(ctx)
	if err != nil {
		return nil, fmt.Errorf("failed to load DiscoverySnapshot resources: %w", err)
	}

	// Convert to Fabrica resources
	var resources []*v1.DiscoverySnapshot
	for _, entResource := range entResources {
		fabricaResource, err := FromEntResource(ctx, entResource)
		if err != nil {
			// Log error but continue with other resources
			continue
		}
		resources = append(resources, fabricaResource.(*v1.DiscoverySnapshot))
	}

	return resources, nil
}

// LoadDiscoverySnapshot loads a single DiscoverySnapshot resource by UID from Ent storage
func LoadDiscoverySnapshot(ctx context.Context, uid string) (*v1.DiscoverySnapshot, error) {
	if entClient == nil {
		return nil, fmt.Errorf("ent client not initialized")
	}

	// Query by UID and kind
	entResource, err := entClient.Resource.Query().
		Where(
			entresource.UIDEQ(uid),
			entresource.KindEQ("DiscoverySnapshot"),
		).
		WithLabels().
		WithAnnotations().
		Only(ctx)
	if err != nil {
		if ent.IsNotFound(err) {
			return nil, ErrNotFound
		}
		return nil, fmt.Errorf("failed to load DiscoverySnapshot %s: %w", uid, err)
	}

	// Convert to Fabrica resource
	fabricaResource, err := FromEntResource(ctx, entResource)
	if err != nil {
		return nil, err
	}

	return fabricaResource.(*v1.DiscoverySnapshot), nil
}

// SaveDiscoverySnapshot saves a DiscoverySnapshot resource to Ent storage
func SaveDiscoverySnapshot(ctx context.Context, resource *v1.DiscoverySnapshot) error {
	if entClient == nil {
		return fmt.Errorf("ent client not initialized")
	}

	// Convert to Ent entity
	createBuilder, labels, annotations, err := ToEntResource(resource)
	if err != nil {
		return fmt.Errorf("failed to convert DiscoverySnapshot to ent: %w", err)
	}

	// Use upsert pattern: try to update, if not exists then create
	entResource, err := entClient.Resource.Query().
		Where(entresource.UIDEQ(resource.GetUID())).
		Only(ctx)

	if err != nil && !ent.IsNotFound(err) {
		return fmt.Errorf("failed to check DiscoverySnapshot existence: %w", err)
	}

	var savedResource *ent.Resource
	if ent.IsNotFound(err) {
		// Create new resource
		savedResource, err = createBuilder.Save(ctx)
		if err != nil {
			return fmt.Errorf("failed to create DiscoverySnapshot: %w", err)
		}
	} else {
		// Update existing resource
		spec, _ := json.Marshal(resource.Spec)
		status, _ := json.Marshal(resource.Status)

		savedResource, err = entClient.Resource.UpdateOne(entResource).
			SetName(resource.Metadata.Name).
			SetAPIVersion(resource.APIVersion).
			SetSpec(spec).
			SetStatus(status).
			SetUpdatedAt(time.Now()).
			Save(ctx)
		if err != nil {
			return fmt.Errorf("failed to update DiscoverySnapshot: %w", err)
		}
	}

	// Save labels
	if err := saveLabels(ctx, savedResource.ID, labels); err != nil {
		return err
	}

	// Save annotations
	if err := saveAnnotations(ctx, savedResource.ID, annotations); err != nil {
		return err
	}

	return nil
}

// DeleteDiscoverySnapshot deletes a DiscoverySnapshot resource from Ent storage
func DeleteDiscoverySnapshot(ctx context.Context, uid string) error {
	if entClient == nil {
		return fmt.Errorf("ent client not initialized")
	}

	// Delete by UID
	deleted, err := entClient.Resource.Delete().
		Where(
			entresource.UIDEQ(uid),
			entresource.KindEQ("DiscoverySnapshot"),
		).
		Exec(ctx)

	if err != nil {
		return fmt.Errorf("failed to delete DiscoverySnapshot %s: %w", uid, err)
	}

	if deleted == 0 {
		return ErrNotFound
	}

	return nil
}

var Backend fabricaStorage.StorageBackend = &entStorageBackend{}

var _ fabricaStorage.StorageBackend = (*entStorageBackend)(nil)

type entStorageBackend struct{}

func ensureBackendReady() error {
	if entClient == nil {
		return fmt.Errorf("ent client not initialized")
	}
	return nil
}

func (b *entStorageBackend) LoadAll(ctx context.Context, resourceType string) ([]json.RawMessage, error) {
	if err := ensureBackendReady(); err != nil {
		return nil, err
	}
	switch resourceType {
	case "Device":
		resources, err := LoadAllDevices(ctx)
		if err != nil {
			return nil, err
		}
		return marshalTypedList(resources)
	case "DiscoverySnapshot":
		resources, err := LoadAllDiscoverySnapshots(ctx)
		if err != nil {
			return nil, err
		}
		return marshalTypedList(resources)
	default:
		return nil, fmt.Errorf("storage: unsupported resource type %s", resourceType)
	}
}

func (b *entStorageBackend) Load(ctx context.Context, resourceType, uid string) (json.RawMessage, error) {
	if err := ensureBackendReady(); err != nil {
		return nil, err
	}
	switch resourceType {
	case "Device":
		resource, err := LoadDevice(ctx, uid)
		if err != nil {
			return nil, err
		}
		return marshalResource(resource)
	case "DiscoverySnapshot":
		resource, err := LoadDiscoverySnapshot(ctx, uid)
		if err != nil {
			return nil, err
		}
		return marshalResource(resource)
	default:
		return nil, fmt.Errorf("storage: unsupported resource type %s", resourceType)
	}
}

func (b *entStorageBackend) Save(ctx context.Context, resourceType, uid string, data json.RawMessage) error {
	if err := ensureBackendReady(); err != nil {
		return err
	}
	switch resourceType {
	case "Device":
		var res v1.Device
		if err := json.Unmarshal(data, &res); err != nil {
			return fmt.Errorf("failed to unmarshal Device: %w", err)
		}
		res.Metadata.UID = uid
		return SaveDevice(ctx, &res)
	case "DiscoverySnapshot":
		var res v1.DiscoverySnapshot
		if err := json.Unmarshal(data, &res); err != nil {
			return fmt.Errorf("failed to unmarshal DiscoverySnapshot: %w", err)
		}
		res.Metadata.UID = uid
		return SaveDiscoverySnapshot(ctx, &res)
	default:
		return fmt.Errorf("storage: unsupported resource type %s", resourceType)
	}
}

func (b *entStorageBackend) Delete(ctx context.Context, resourceType, uid string) error {
	if err := ensureBackendReady(); err != nil {
		return err
	}
	switch resourceType {
	case "Device":
		return DeleteDevice(ctx, uid)
	case "DiscoverySnapshot":
		return DeleteDiscoverySnapshot(ctx, uid)
	default:
		return fmt.Errorf("storage: unsupported resource type %s", resourceType)
	}
}

func (b *entStorageBackend) Exists(ctx context.Context, resourceType, uid string) (bool, error) {
	_, err := b.Load(ctx, resourceType, uid)
	if err != nil {
		if errors.Is(err, ErrNotFound) {
			return false, nil
		}
		return false, err
	}
	return true, nil
}

func (b *entStorageBackend) List(ctx context.Context, resourceType string) ([]string, error) {
	items, err := b.LoadAll(ctx, resourceType)
	if err != nil {
		return nil, err
	}
	var out []string
	for _, item := range items {
		uid, err := extractUID(item)
		if err != nil {
			return nil, err
		}
		out = append(out, uid)
	}
	return out, nil
}

func (b *entStorageBackend) LoadWithVersion(ctx context.Context, resourceType, uid, version string) (json.RawMessage, string, error) {
	data, err := b.Load(ctx, resourceType, uid)
	if err != nil {
		return nil, "", err
	}
	if version == "" {
		version = ""
	}
	return data, version, nil
}

func (b *entStorageBackend) LoadAllWithVersion(ctx context.Context, resourceType, version string) ([]json.RawMessage, error) {
	return b.LoadAll(ctx, resourceType)
}

func (b *entStorageBackend) SaveWithVersion(ctx context.Context, resourceType, uid string, data json.RawMessage, version string) error {
	return b.Save(ctx, resourceType, uid, data)
}

func (b *entStorageBackend) Close() error {
	return nil
}

type StorageClient struct {
	backend fabricaStorage.StorageBackend
}

var _ reconcile.ClientInterface = (*StorageClient)(nil)

func NewStorageClient() *StorageClient {
	if err := ensureBackendReady(); err != nil {
		panic(err)
	}
	return &StorageClient{backend: Backend}
}

func (c *StorageClient) Get(ctx context.Context, kind, uid string) (interface{}, error) {
	raw, err := c.backend.Load(ctx, kind, uid)
	if err != nil {
		return nil, err
	}

	// Unmarshal based on kind
	switch kind {
	case "Device":
		var resource v1.Device
		if err := json.Unmarshal(raw, &resource); err != nil {
			return nil, fmt.Errorf("failed to unmarshal Device: %w", err)
		}
		return &resource, nil
	case "DiscoverySnapshot":
		var resource v1.DiscoverySnapshot
		if err := json.Unmarshal(raw, &resource); err != nil {
			return nil, fmt.Errorf("failed to unmarshal DiscoverySnapshot: %w", err)
		}
		return &resource, nil
	default:
		return nil, fmt.Errorf("unknown resource kind: %s", kind)
	}
}

func (c *StorageClient) List(ctx context.Context, kind string) ([]interface{}, error) {
	items, err := c.backend.LoadAll(ctx, kind)
	if err != nil {
		return nil, err
	}

	// Unmarshal based on kind
	switch kind {
	case "Device":
		result := make([]interface{}, 0, len(items))
		for _, item := range items {
			var resource v1.Device
			if err := json.Unmarshal(item, &resource); err != nil {
				return nil, fmt.Errorf("failed to unmarshal Device: %w", err)
			}
			result = append(result, &resource)
		}
		return result, nil
	case "DiscoverySnapshot":
		result := make([]interface{}, 0, len(items))
		for _, item := range items {
			var resource v1.DiscoverySnapshot
			if err := json.Unmarshal(item, &resource); err != nil {
				return nil, fmt.Errorf("failed to unmarshal DiscoverySnapshot: %w", err)
			}
			result = append(result, &resource)
		}
		return result, nil
	default:
		return nil, fmt.Errorf("unknown resource kind: %s", kind)
	}
}

func (c *StorageClient) Update(ctx context.Context, resource interface{}) error {
	data, err := json.Marshal(resource)
	if err != nil {
		return fmt.Errorf("failed to marshal resource: %w", err)
	}

	// Extract kind and UID based on type
	switch res := resource.(type) {
	case *v1.Device:
		return c.backend.Save(ctx, "Device", res.Metadata.UID, data)
	case *v1.DiscoverySnapshot:
		return c.backend.Save(ctx, "DiscoverySnapshot", res.Metadata.UID, data)
	default:
		return fmt.Errorf("unsupported resource type: %T", resource)
	}
}

func (c *StorageClient) Create(ctx context.Context, resource interface{}) error {
	return c.Update(ctx, resource)
}

func (c *StorageClient) Delete(ctx context.Context, kind, uid string) error {
	return c.backend.Delete(ctx, kind, uid)
}

func marshalTypedList[T any](items []*T) ([]json.RawMessage, error) {
	var out []json.RawMessage
	for _, item := range items {
		data, err := json.Marshal(item)
		if err != nil {
			return nil, err
		}
		out = append(out, json.RawMessage(data))
	}
	return out, nil
}

func marshalResource(resource interface{}) (json.RawMessage, error) {
	data, err := json.Marshal(resource)
	if err != nil {
		return nil, err
	}
	return json.RawMessage(data), nil
}

func extractUID(raw json.RawMessage) (string, error) {
	var wrapper struct {
		Metadata struct {
			UID string `json:"uid"`
		} `json:"metadata"`
	}
	if err := json.Unmarshal(raw, &wrapper); err != nil {
		return "", err
	}
	return wrapper.Metadata.UID, nil
}
